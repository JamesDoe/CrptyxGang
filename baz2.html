<!DOCTYPE html>
<html lang="en">

<head>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css?family=Teko|Roboto+Condensed|Roboto" rel="stylesheet">

    <!-- <link href="https://fonts.googleapis.com/css2?display=swap&family=Roboto+Condensed|Roboto" rel="stylesheet"> -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://unpkg.com/vue"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.0.1/d3.min.js"
        integrity="sha512-1e0JvdNhUkvFbAURPPlFKcX0mWu/b6GT9e0uve7BW4MFxJ15q4ZCd/Llz+B7/oh+qhw7/l6Q1ObPt6aAuR01+Q=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdn.socket.io/3.1.3/socket.io.min.js"
        integrity="sha384-cPwlPLvBTa3sKAgddT6krw0cJat7egBga3DJepJyrLl4Q9/5WLra3rrnMcyTyOnh"
        crossorigin="anonymous"></script>


    <title>Document</title>
    <style>
        body {
            background-color: #999;
        }

        /* .6_17 { 
	overflow:hidden;
} */
        .e6_17 {
            width: 180px;
            height: 84.9056625366211px;
            position: relative;
            margin: .38em;
        }

        .e1_2 {
            box-shadow: 0px 0.4245283007621765px 1.698113203048706px rgba(0, 0, 0, 0.25);
            /* background-color: rgba(255, 255, 255, 1); */
            background-color: #fefefe;
            width: 180px;
            height: 84.9056625366211px;
            /* position:absolute; */
            left: 0px;
            top: 0px;
            border-radius: 3.8207547664642334px;
        }

        .e1_2_1 {
            box-shadow: 0px 0.4245283007621765px 1.698113203048706px rgba(0, 0, 0, 0.25);
            background-color: rgba(255, 255, 255, 1);
            /* width: 180px; */
            /* height: 84.9056625366211px; */
            /* position:absolute; */
            /* left: 0px; */
            /* top: 0px; */
            display: inline-flex;
            padding: 1em;
            border-radius: 3.8207547664642334px;
        }

        .ticker_name {
            color: black;
            width: 78.96226501464844px;
            height: 10.188679695129395px;
            position: absolute;
            left: 9px;
            top: 67.5px;
            font-family: Roboto;
            text-align: left;
            font-size: 10.188679695129395px;
            letter-spacing: 0;
        }

        .e6_18 {
            color: rgba(187.00000405311584, 187.00000405311584, 187.00000405311584, 1);
            width: 78.96226501464844px;

            height: 10.188679695129395px;
            position: absolute;
            right: 9px;
            top: 67.5px;
            font-family: Roboto;
            text-align: right;
            font-size: 10.188679695129395px;
            letter-spacing: 0;
        }

        .ticker {
            opacity: 0.62;
            color: rgba(119.00000050663948, 119.00000050663948, 119.00000050663948, 1);
            width: 158.34906005859375px;
            height: 37.97288513183594px;
            position: absolute;
            font-weight: 600;
            left: 6.79248046875px;
            top: 25.59967041015625px;
            font-family: 'Roboto Condensed';
            text-align: left;
            font-size: 40.75471878051758px;
            letter-spacing: 0;
        }

        .e6_7 {
            font-weight: 900;

            color: rgba(0, 0, 0, 1);
            width: 96.36792755126953px;
            height: 23.03972816467285px;
            position: absolute;
            left: 6.79248046875px;
            top: 6.8265380859375px;
            font-family: 'Roboto Condensed';
            text-align: left;
            font-size: 20.37735939025879px;
            letter-spacing: 0;

        }

        .percent_change {
            color: #222;
            width: 56.88679885864258px;
            height: 20.47975730895996px;
            position: absolute;
            left: 103.160400390625px;
            top: 11px;
            font-family: 'Roboto Condensed';
            text-align: left;
            font-size: 15.283019065856934px;
            letter-spacing: 0;
            font-weight: 900;

        }

        .time_scale_option_9 {
            color: #BBB;
            /* width: 13.160377502441406px; */
            height: 6px;
            position: absolute;
            left: 108px;
            font-family: 'Roboto';
            text-align: center;
            /* font-size: 5.94339656829834px; */
            letter-spacing: 0;
            font-weight: 900;
            display: flex;
            align-items: center;
            text-rendering: optimizeLegibility;
        }

        .time_scale_option_9>span {
            padding: 0 1.5px;
            opacity: .8;
            user-select: none;
        }

        .time_scale_option_9>span:hover {
            opacity: 1;
            color: dodgerblue;
            font-weight: 900;
            cursor: pointer;
        }

        [class^='time_scale_option_'] {


            font-size: 8px;
            top: 4px;
            font-family: 'Roboto';
        }

        /* https://www.w3schools.com/css/css_tooltip.asp */
        .tooltip {
            position: relative;
            display: inline-block;
            border-bottom: 1px dotted black;
            /* If you want dots under the hoverable text */
        }

        /* Tooltip text */
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 120px;
            background-color: black;
            color: #BBB;
            text-align: center;
            padding: 5px 0;
            border-radius: 6px;

            /* Position the tooltip text - see examples below! */
            position: absolute;
            z-index: 1;
        }

        /* Show the tooltip text when you mouse over the tooltip container */
        .tooltip:hover .tooltiptext {
            visibility: visible;
        }

        input {
            border: 0;
        }

        input:focus {
            outline: none;
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta2/css/all.min.css"
        integrity="sha512-YWzhKL2whUzgiheMoBFwW8CKV4qpHQAEuvilg9FAn5VJUDwKZZxkJNuGM4XkWuk94WCrrwslk8yWNGmY1EduTA=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dexie/3.2.0-rc.2/dexie.min.js"
        integrity="sha512-hJ1eR4h0vQbaojZAlCt5mDHE255IeqdRpK4IyBnXvAYDyBYfxMu2V2CA8PLAh8DdLB6x9ei9GRs+v2dUIGIjDQ=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdn.jsdelivr.net/npm/dexie-observable@3.0.0-beta.11/dist/dexie-observable.min.js"></script>

</head>

<body>
    <div id="app">
        <!-- https://codepen.io/nikhil8krishnan/pen/rVoXJa -->

        <div style="display: inline-flex; flex-direction: column;">
            <!-- BEGIN COMPONENT -->


            <div class=e6_17 v-for="c in cryptocompare_prices">

                <svg style="position:absolute" viewBox="0 0 180 84.905662536621" xmlns="http://www.w3.org/2000/svg">


                    <template
                        v-if="historical[minutely_data_source]&&historical[minutely_data_source][c[0]]&&historical[minutely_data_source][c[0]].minutely">

                        <template v-for="s in [{data: historical[minutely_data_source][c[0]].minutely,x:d3.scaleTime().domain(d3.extent(historical[minutely_data_source][c[0]].minutely.map(e=>new Date(e.time)))).range([0,180]).nice(), 
                        y: d3.scaleLinear().domain([Math.min(...historical[minutely_data_source][c[0]].minutely.map(e=>e.low)), Math.max(...historical[minutely_data_source][c[0]].minutely.map(e=>e.high))]).range([84,0]).nice() 
                    }]">
                            <rect style="shape-rendering:crispEdges"
                                :fill="s.y(d.open)<s.y(d.close)?'#61FE61':'#FF6464'" v-for="d in s.data"
                                :x="(Math.round((s.x(d.time) + Number.EPSILON) * 100) / 100)-.125" :y="s.y(d.high)"
                                width=".25"
                                :height="(Math.round(((s.y(d.low)-s.y(d.high)) + Number.EPSILON) * 100) / 100)" />
                            <rect style="shape-rendering:crispEdges"
                                :fill="s.y(d.open)<s.y(d.close)?'#61FE61':'#FF6464'" v-for="d in s.data"
                                :x="(Math.round((s.x(d.time) + Number.EPSILON) * 100) / 100)-.5"
                                :y="Math.max(s.y(d.open),s.y(d.close))" width="1"
                                :height="(Math.round((Math.abs(s.y(d.open)-s.y(d.close)) + Number.EPSILON) * 100) / 100)" />
                        </template>
                    </template>
                </svg>




                <div @click="console.log(c)" class="e1_2"></div><span
                    class="ticker_name">{{coin_info_df.row(c[0],'symbol')[0].name_coinmarketcap}}</span><span
                    class="e6_18">$125.00 +25%</span><span class="ticker">{{c[0]}}</span><span
                    class="e6_7">${{c[1].USD.PRICE}}</span>
                <div class="time_scale_option_9"><span
                        :style="tf==='24HR'?'opacity: 1; color:dodgerblue;font-weight:900;':''"
                        v-for="tf in ['24HR','DAY','HOUR']">{{tf}}</span></div>
                <!-- https://iconmonstr.com/arrow-12-svg/ -->
                <span v-if="c[1].USD.CHANGEPCT24HOUR" class="percent_change"><svg
                        :style="`${Math.round((c[1].USD.CHANGEPCT24HOUR + Number.EPSILON) * 100) / 100 > 0 ? 'transform: rotate(270deg);fill: #61FE61':'transform: rotate(90deg);fill: #FF6464'}`"
                        xmlns="http://www.w3.org/2000/svg" width="9" height="9" viewBox="0 0 24 24">
                        <path d="M24 12l-12-9v5h-12v8h12v5l12-9z" />
                    </svg>{{Math.abs(Math.round((c[1].USD.CHANGEPCT24HOUR + Number.EPSILON) * 100) / 100)}}%</span>


            </div>

            <!-- END COMPONENT -->

        </div>

        <div style="display: inline-flex; flex-direction: column; justify-items: center;">
            <div class="e1_2_1"><i class="fas fa-search"></i><input type="text"></div>
            <div class="e1_2_1">

                <div>

                    <div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M24 14.187v-4.374c-2.148-.766-2.726-.802-3.027-1.529-.303-.729.083-1.169 1.059-3.223l-3.093-3.093c-2.026.963-2.488 1.364-3.224 1.059-.727-.302-.768-.889-1.527-3.027h-4.375c-.764 2.144-.8 2.725-1.529 3.027-.752.313-1.203-.1-3.223-1.059l-3.093 3.093c.977 2.055 1.362 2.493 1.059 3.224-.302.727-.881.764-3.027 1.528v4.375c2.139.76 2.725.8 3.027 1.528.304.734-.081 1.167-1.059 3.223l3.093 3.093c1.999-.95 2.47-1.373 3.223-1.059.728.302.764.88 1.529 3.027h4.374c.758-2.131.799-2.723 1.537-3.031.745-.308 1.186.099 3.215 1.062l3.093-3.093c-.975-2.05-1.362-2.492-1.059-3.223.3-.726.88-.763 3.027-1.528zm-4.875.764c-.577 1.394-.068 2.458.488 3.578l-1.084 1.084c-1.093-.543-2.161-1.076-3.573-.49-1.396.581-1.79 1.693-2.188 2.877h-1.534c-.398-1.185-.791-2.297-2.183-2.875-1.419-.588-2.507-.045-3.579.488l-1.083-1.084c.557-1.118 1.066-2.18.487-3.58-.579-1.391-1.691-1.784-2.876-2.182v-1.533c1.185-.398 2.297-.791 2.875-2.184.578-1.394.068-2.459-.488-3.579l1.084-1.084c1.082.538 2.162 1.077 3.58.488 1.392-.577 1.785-1.69 2.183-2.875h1.534c.398 1.185.792 2.297 2.184 2.875 1.419.588 2.506.045 3.579-.488l1.084 1.084c-.556 1.121-1.065 2.187-.488 3.58.577 1.391 1.689 1.784 2.875 2.183v1.534c-1.188.398-2.302.791-2.877 2.183zm-7.125-5.951c1.654 0 3 1.346 3 3s-1.346 3-3 3-3-1.346-3-3 1.346-3 3-3zm0-2c-2.762 0-5 2.238-5 5s2.238 5 5 5 5-2.238 5-5-2.238-5-5-5z"/></svg><span style="font-size: 1.62em; font-weight: 900; font-family: 'Roboto Condensed';"> Settings</span></div>
                    <div>Current Price Data: 
                    <span @click="console.log(c_price=!c_price)"><input style="pointer-events:none;"
                            v-model="c_price" type="checkbox" name="" id=""></span></div>
                    <div>Minute OHLC Data: 
                    <span @click="console.log(minute_OHLC=!minute_OHLC)"><input style="pointer-events:none;"
                            v-model="minute_OHLC" type="checkbox" name="" id=""></span></div>
                    <div>
                        Current Price Data Source: <input v-model="minutely_data_source" type="text" disabled name=""
                            id="">
                    </div>
                    <div>
                        Minute Candle Data Source: <input v-model="minutely_data_source" type="text" disabled name=""
                            id="">
                    </div>
                </div>
                <svg style="width: 100%" viewBox="0 0 180 84.905662536621" xmlns="http://www.w3.org/2000/svg">
                    <text v-if="ticker_c">{{c[0]}}</text>
                </svg>
                <!--        <svg style="position:absolute" viewBox="0 0 180 84.905662536621" xmlns="http://www.w3.org/2000/svg">
                    
                    
                    <template v-if="cryptocompare_historical[c[0]]">
                        <text x=5 y=10>{{ c[0]}}</text>

                        <template v-for="s in [{data: cryptocompare_historical[c[0]].minutely.Data.Data,x:d3.scaleTime().domain(d3.extent(cryptocompare_historical[c[0]].minutely.Data.Data.map(e=>new Date(e.time)))).range([0,180]).nice(), 
                            y: d3.scaleLinear().domain([Math.min(...cryptocompare_historical[c[0]].minutely.Data.Data.map(e=>e.low)), Math.max(...cryptocompare_historical[c[0]].minutely.Data.Data.map(e=>e.high))]).range([84,0]).nice() 
                        }]">
                             <line stroke="whitesmoke" v-for="t in s.x.ticks()" :x1="s.x(new Date(t))"
                                :x2="s.x(new Date(t))" y1="0" :y2="84.905662536621" /> 
                            <line stroke="whitesmoke" v-for="t in s.y.ticks().slice(1, s.y.ticks().length-1).filter((e,i)=>i%2)" :x1="0" :x2="180"
                                :y1="s.y(t)" :y2="s.y(t)" />
                       


                            <rect style="shape-rendering:crispEdges"
                                :fill="s.y(d.open)<s.y(d.close)?'#61FE61':'#FF6464'" v-for="d in s.data"
                                :x="(Math.round((s.x(d.time) + Number.EPSILON) * 100) / 100)-.125" :y="s.y(d.high)"
                                width=".25"
                                :height="(Math.round(((s.y(d.low)-s.y(d.high)) + Number.EPSILON) * 100) / 100)" />
                            <rect style="shape-rendering:crispEdges"
                                :fill="s.y(d.open)<s.y(d.close)?'#61FE61':'#FF6464'" v-for="d in s.data"
                                :x="(Math.round((s.x(d.time) + Number.EPSILON) * 100) / 100)-.5"
                                :y="Math.max(s.y(d.open),s.y(d.close))" width="1"
                                :height="(Math.round((Math.abs(s.y(d.open)-s.y(d.close)) + Number.EPSILON) * 100) / 100)" />
                        </template>
                    </template>
                </svg> -->






            </div>
        </div>
    </div>
</body>

<script src="config.js"></script>
<script>
    const tickers = [], colors = ['orange', 'blue', 'indigo', 'violet', 'cyan', 'magenta', 'yellow', 'black']
    const app = new Vue({
        methods: {
            async get_minutely_from_cryptocompare() {
                if (!this.minute_OHLC) return console.log('Minutely data not in sync.');
                let now = Math.round(Date.now() / 1000), then = now - (24 * 60 * 60), ticker_i = this.tickers.length;
                (async function (app) {
                    let _datapoints = await cryptxgang_db.data.where('time').below(then).delete().then(count => {
                        if (count) console.log(`Deleted ${count} datapoints earlier than ${new Date(then * 1000)}`)
                    });
                    let s = Date.now()
                    console.log('retrieving OHLVC minutely data from cryptocompare...');
                    while (app.tickers[--ticker_i]) {
                        if (!app.minute_OHLC) {
                            console.log('Minutely data not in sync.');
                            break;
                        }
                        console.log('querying ' + app.tickers[ticker_i] + ' OHLVC minutely data from cryptocompare...');
                        let l = (_datapoints = await cryptxgang_db.data.where('freq').equals(60).and(dp => dp.symbol === app.tickers[ticker_i]).and(dp => dp.time >= Math.round(Date.now() / 1000)).toArray()).length;

                        if (!l) {
                            console.log('retrieving ' + app.tickers[ticker_i] + ' OHLVC minutely data from cryptcompare...');
                            await get_cryptocompare_minutely(app.tickers[ticker_i]).then(async datapoints => {
                                datapoints.forEach(async (dp, i) => {
                                    let fred = await cryptxgang_db.data.where('[freq+symbol+time]').equals([60, app.tickers[ticker_i], dp.time]).count();
                                    // console.log(dp) 
                                    // console.log({ fred })
                                    if (fred) return;
                                    //     //     datapoints.map(g => ({ ...g, symbol, freq: 60, platform: 'cryptocompare' })).forEach(async (dp, i) => {
                                    //     //         // console.log({ fred })
                                    //     //         // console.log({ dp })
                                    let waldo = await cryptxgang_db.data.put({ ...dp, symbol: app.tickers[ticker_i], freq: 60, platform: 'cryptocompare' });
                                    console.log(`Minutely cryptocompare datapoint {time: ${dp.time}} added for ${app.tickers[ticker_i]}`);
                                });
                            })
                        };

                        let quux = await cryptxgang_db.data.where('freq').equals(60).and(dp => dp.symbol === app.tickers[ticker_i]).toArray();
                        await wait(3000).then(async k => {
                            console.log(app.tickers[ticker_i] + ' waited ' + (Date.now() - s) + ' ms');
                        })
                    };
                    console.log('done retrieving OHLVC minutely data from cryptcompare...');

                })(app);
                this.tickers.forEach(async symbol => {

                    // let _datapoints = await cryptxgang_db.data.where('time').below(then).delete().then(count => {
                    //     if (count) console.log(`Deleted ${count} datapoints earlier than ${new Date(then * 1000)}`)
                    // })//await cryptxgang_db.data.where('time').below(then).toArray(), l = _datapoints.length;;

                    // console.log('querying ' + symbol + ' OHLVC minutely data from cryptocompare...');
                    // console.log('looking for ' + symbol + ' OHLVC minutely datapoints from cryptcompare...');

                    // console.log([60, symbol, Math.round(Date.now() / 1000)].join(''))
                    // let l = (_datapoints = await cryptxgang_db.data.where('[freq+symbol+time]').aboveOrEqual([60, symbol, Math.round(Date.now() / 1000)]).toArray()).length;
                    let l = (_datapoints = await cryptxgang_db.data.where('freq').equals(60).and(dp => dp.symbol === symbol).and(dp => dp.time >= Math.round(Date.now() / 1000)).toArray()).length;

                    // console.log({[symbol]:l})
                    // console.log({ _datapoints })


                    if (!l) {
                        // return;
                        // let xyzzy = await get_cryptocompare_minutely(symbol).then(async datapoints => new Promise(async (resolve, reject) => {

                        //     console.log('retrieving ' + symbol + ' OHLVC minutely data from cryptcompare...');
                        //     datapoints.map(g => ({ ...g, symbol, freq: 60, platform: 'cryptocompare' })).forEach(async (dp, i) => {
                        //         let fred = await cryptxgang_db.data.where('[freq+symbol+time]').equals([60, symbol, dp.time]).count();
                        //         // console.log({ fred })
                        //         if (fred) return;
                        //         // console.log({ dp })
                        //         let waldo = await cryptxgang_db.data.put(dp);
                        //         console.log(`Minutely cryptocompare datapoint {time: ${dp.time}} added for ${symbol}`);
                        //     });
                        //     let s = Date.now()
                        //     console.log('waiting...')
                        //     await wait(3000).then(k => {
                        //         console.log('waited ' + (Date.now() - s) + ' ms');
                        //         resolve(1);
                        //     });

                        // }));

                    };
                })
            },

            async get_price_from_cryptocompare() {
                if (!this.c_price) return console.log('Price data not in sync.');
                let foo = await get_cryptocompare_prices(this.tickers);//.then(e => );
                if (foo.Response === 'Error') return alert(foo.Message);
                console.log('getting prices from cryptcompare...');
                this.cryptocompare_prices = Object.entries(foo.RAW);
            }
        },
        computed: {
            todaysprices() {
                return Object.fromEntries(this.cryptocompare_prices)
            },
            historical() {
                return this.datapoints.reduce((a, c) => {
                    if (!a[c.platform]) a[c.platform] = {};
                    if (!a[c.platform][c.symbol]) a[c.platform][c.symbol] = {};
                    if (!a[c.platform][c.symbol].minutely) a[c.platform][c.symbol].minutely = [];
                    a[c.platform][c.symbol].minutely.push(c);
                    return a;
                }, {});
            },
            coin_info_df() {
                return new DataFrame(this.coins, ['name', 'symbol', 'id_coinmarketcap', 'name_coinmarketcap', 'id_coingecko', 'name_coingecko'])
            },
        },
        el: "#app",
        data: {
            datapoints: [],
            api_key: '583932a385edf4530535beb8494248479013f3b340bd5e52368f84b29e227492',
            coins,
            colors,
            console,
            cryptocompare_prices: [],
            cryptocompare_historical,
            d3,
            minute_OHLC: false,
            c_price: true,
            minutely_data_source: "cryptocompare",
            ticker_c: null,
            tickers
        },
        async mounted() {
            cryptxgang_db = new Dexie("cryptxgang_db");
            // let foo = await Dexie.exists(settings);
            // console.log(foo)
            cryptxgang_db.version(1).stores({
                settings: 'name,value',
                data: '[freq+symbol+time],platform,freq,symbol,close,conversionSymbol,conversionType,high,low,open,time,volumefrom,volumeto'

            });
            // cryptxgang_db.data.hook("updating", function (mods, primKey, obj, trans) {
            //     console.log({ obj })
            // })
            //
            // Put some data into it
            //

            // cryptxgang_db.settings.put({ name: "tickers", value: ['ONE', 'BTC'] }).then(function () {
            // //     //
            // //     // Then when data is stored, read from it
            // //     //
            // return cryptxgang_db.settings.get('tickers');
            // })


            // Promise.resolve(cryptxgang_db.settings.get('tickers'))
            new Promise(async function (resolve, reject) {
                await cryptxgang_db.settings.get('tickers').then(async e => {
                    if (e && e.value) return resolve(e.value);
                    e = ['ONE', 'BTC'];
                    await cryptxgang_db.settings.put({ name: "tickers", value: e }).then(f => resolve(e))
                })
            })
                .then(async function (value) {
                    app.tickers = value;
                    let h = {};
                    let foobar = await Promise.all(app.tickers.map(async e => await cryptxgang_db.data.where('freq').equals(60).and(dp => dp.symbol === e).toArray()))
                    console.log(app.datapoints = [].concat(...foobar));
                    _heartbeat(app.get_price_from_cryptocompare, 20000);
                    _heartbeat(app.get_minutely_from_cryptocompare, 45000);

                }).catch(function (error) {
                    //
                    // Finally don't forget to catch any error
                    // that could have happened anywhere in the
                    // code blocks above.
                    //
                    alert("Ooops: " + error);
                });
            // _heartbeat(_thump1);
            // _heartbeat(_thump2, 5000);
            // fetch('https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ONE,BTC,VET,MATIC,ALGO&tsyms=USD').then(e => e.json()).then(e => this.cryptocompare_prices = Object.entries(e.RAW))
        }
    });

    function wait(ms) { return new Promise((r, j) => setTimeout(r, ms)); }


    function DataFrame(data, col_headers, rows_labels) {
        if (!col_headers) col_headers = data.splice(0, 1)[0];
        let rows = {};
        data = data.filter(r => r.some(rr => rr));
        data.forEach((e, i) => {
            e.forEach((ee, ii) => {
                (rows[ee.toString()] || (rows[ee.toString()] = [])).push([i.toString(), ii.toString()])
            })
        })
        let
            cols = col_headers.reduce((a, c, i) => {
                a[c] = data.map(e => e[i]);
                return a;
            }, {})
        return {
            col(col_name) {
                if (!col_name) return col_headers
                return cols[col_name]
            },
            row(row_value, col_name) {
                if (!row_value) return data.map(r => Object.fromEntries(d3.zip(col_headers, r)));
                if (col_name) return rows[row_value] && rows[row_value].map(r => data[r[0]]).filter(r => r[col_headers.indexOf(col_name)] == row_value).map(r => d3.zip(col_headers, r)).map(r => Object.fromEntries(r));
                return rows[row_value] && Array.from(new Set(rows[row_value].map(r => r[0]))).map(r => data[r[0]]);
            }
        };
    }
    String.prototype.hashCode = function () {
        var hash = 0, i, chr;
        if (this.length === 0) return hash;
        for (i = 0; i < this.length; i++) {
            chr = this.charCodeAt(i);
            hash = ((hash << 5) - hash) + chr;
            hash |= 0; // Convert to 32bit integer
        }
        return hash;
    };


    function get_cryptocompare_minutely(symbol) {
        // return console.log()

        return fetch(`https://min-api.cryptocompare.com/data/v2/histominute?fsym=${symbol}&tsym=USD&limit=300&api_key=${app.api_key}`).then(e => e.json()).then(e => e.Data.Data)

    }

    function get_cryptocompare_prices(array) {
        // return fetch(`https://min-api.cryptocompare.com/data/pricemultifull?fsyms=${array.join(',')}&tsyms=USD}`).then(e => e.json()).then(e => e)
        return fetch(`https://min-api.cryptocompare.com/data/pricemultifull?fsyms=${array.join(',')}&tsyms=USD&api_key=${app.api_key}`).then(e => e.json()).then(e => e)

    }

    async function _thump1() {
        console.log('getting today\'s prices from cryptcompare...');
        let foo = await get_cryptocompare_prices(['ONE', 'BTC', 'VET', 'MATIC', 'ALGO', 'ETH', 'GRV', 'USDT']).then(e => this.cryptocompare_prices = Object.entries(e.RAW));
        app.cryptocompare_prices = foo;
    }

    async function _thump2() {
        console.log('getting today\'s winners and losers...')
        // let foo = await get_cryptocompare_prices(['ONE', 'BTC', 'VET', 'MATIC', 'ALGO']).then(e => this.cryptocompare_prices = Object.entries(e.RAW));
        // app.cryptocompare_prices = foo;
    }

    async function _heartbeat(func, wait_time = 15000) {
        if (!func) return 0;
        await func();
        return setTimeout(async () => {
            // while (_paused) await wait(1000);
            return _heartbeat(func, wait_time);
        }, wait_time)
    };
</script>

</html>